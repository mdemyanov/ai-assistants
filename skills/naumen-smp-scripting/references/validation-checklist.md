# Чек-лист валидации скриптов Naumen SMP

Используй этот чек-лист для проверки скриптов перед выкладкой в продакшен.

---

## Производительность

- [ ] **Лимиты в utils.find** — используется `sp.limit()` для потенциально больших выборок
- [ ] **Единый utils.edit** — все изменения одного объекта в одном вызове
- [ ] **Кэширование** — повторные вызовы методов сохранены в переменные
- [ ] **Нет вычислимых атрибутов в поиске** — в `utils.find/count` только хранимые атрибуты
- [ ] **Батчевая обработка** — коллекции >1000 объектов обрабатываются частями

```groovy
// Пример батчевой обработки
def BATCH_SIZE = 500
def offset = 0
while (true) {
    def batch = utils.find('serviceCall', ['state': 'open'],
                          sp.limit(BATCH_SIZE).offset(offset))
    if (!batch) break
    batch.each { ... }
    offset += BATCH_SIZE
}
```

---

## Безопасность

- [ ] **Валидация внешних данных** — params/form проверяются перед использованием
- [ ] **SQL Injection** — параметры HQL передаются через `.set()`, не конкатенацией
- [ ] **XSS** — пользовательский ввод экранируется перед выводом
- [ ] **Права доступа** — проверяется, что user имеет права на операцию
- [ ] **Нет секретов в коде** — токены и пароли не хардкодятся

```groovy
// ПЛОХО - SQL injection
api.db.query("SELECT id FROM T WHERE name = '${params.name}'")

// ХОРОШО
api.db.query("SELECT id FROM T WHERE name = :name").set('name', params.name)
```

---

## Корректность

- [ ] **Null-safe навигация** — используется `?.` для необязательных атрибутов
- [ ] **Проверка пустых коллекций** — перед `op.in()` и HQL IN проверка на непустоту
- [ ] **Правильные типы** — UUID строкой, числа числами, даты датами
- [ ] **changedAttributes** — для проверки изменений вместо сравнения объектов
- [ ] **Сравнение по UUID** — объекты сравниваются через `.UUID`, не `==`

```groovy
// ПЛОХО - падает на null
def name = subject.responsible.parent.title

// ХОРОШО
def name = subject?.responsible?.parent?.title ?: 'Не указано'
```

---

## Стилистика

- [ ] **Структура** — ПАРАМЕТРЫ → ФУНКЦИИ → ОСНОВНОЙ БЛОК
- [ ] **Константы вверху** — настраиваемые значения в начале скрипта
- [ ] **Логирование** — критические операции логируются через `logger`

```groovy
//ПАРАМЕТРЫ------------------------------------------------------------
def TARGET_STATE = 'resolved'

//ФУНКЦИИ--------------------------------------------------------------
def canResolve(sc) { ... }

//ОСНОВНОЙ БЛОК--------------------------------------------------------
if (canResolve(subject)) {
    utils.edit(subject, ['state': TARGET_STATE])
    logger.info("Resolved: ${subject.number}")
}
```

---

## Специфичные проверки по типам

### Скрипт фильтрации
- [ ] Зависимые атрибуты возвращаются при `subject == null`
- [ ] `api.filtration.disableFiltration()` при отсутствии условий
- [ ] Возвращается коллекция объектов или `disableFiltration()`

### Вычислимый атрибут
- [ ] Нет побочных эффектов (edit, create, delete)
- [ ] Быстрое выполнение (используется в списках)
- [ ] Не используется в условиях поиска

### Действие по событию
- [ ] Проверка `changedAttributes` для событий редактирования
- [ ] `@user` передается при вызове edit из скрипта
- [ ] Обработка ошибок интеграций не блокирует сохранение

### Задача планировщика
- [ ] Логирование начала/конца выполнения
- [ ] Обработка ошибок для каждой итерации
- [ ] Ограничение времени выполнения

---

## Типичные ошибки

| Ошибка | Проверка |
|--------|----------|
| `No signature of method` | Типы аргументов совпадают с сигнатурой |
| `NullPointerException` | Есть `?.` или проверка на null |
| `Many objects in result` | utils.get заменен на findFirst |
| `Could not resolve property` | Вычислимый атрибут не в поиске |
| `Could not extract ResultSet` | Список не пуст перед IN |
| `PersistenceContext limit exceeded` | Батчевая обработка >1000 |
| `There is a cycle in the hierarchy` | В JSON только примитивы |

---

## Быстрая проверка (grep-паттерны)

```bash
# Потенциально опасные конструкции
grep -E "utils\.find\([^)]+\)\s*$" script.groovy        # find без лимита
grep -E "utils\.get\([^,]+,\s*\[" script.groovy         # get с map
grep -E "subject\.\w+\.\w+[^?]" script.groovy           # цепочка без ?.
grep -E '"\$\{' script.groovy                           # потенциальная инъекция
grep -E "static\s+def" script.groovy                    # статические поля
```
